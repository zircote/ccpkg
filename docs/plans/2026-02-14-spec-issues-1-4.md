# ccpkg Spec Issues #1-4. Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Revise the ccpkg specification and design document to incorporate host-specific component adapters (#1), update discovery protocol (#2), remote skill references (#3), and Copilot cross-platform strategy (#4).

**Architecture:** Each issue translates to specification-level format changes (manifest fields, lockfile fields, registry protocol schemas) and design-document decisions. This plan covers what the specification defines. not how any particular installer implements it. Implementation details (CLI commands, caching code, UX notifications) belong in a separate implementation plan.

**Tech Stack:** Markdown (spec + design doc), JSON Schema (manifest schema)

**Scope boundary:** This plan modifies the specification format, protocol definitions, and design rationale. It does NOT define CLI command syntax, installer algorithms, or test suites. those are implementation concerns for a separate plan.

---

## Context for All Tasks

### Source Material

The full enriched issue bodies are at:
- Issue #1: https://github.com/zircote/ccpkg/issues/1. Host-specific component adapters and scoping
- Issue #2: https://github.com/zircote/ccpkg/issues/2. Async update discovery and security advisory checks
- Issue #3: https://github.com/zircote/ccpkg/issues/3. Remote skill references and URL-based distribution
- Issue #4: https://github.com/zircote/ccpkg/issues/4. Cross-platform strategy: GitHub Copilot + Claude Code

### Key Files

- Specification: `spec/specification.md`
- Design document: `docs/plans/2026-02-14-ccpkg-design.md`
- Manifest schema: `spec/schemas/manifest.schema.json`

### Current Spec Structure (line numbers for orientation)

| Section | Lines |
|---------|-------|
| Components Object | 215-228 |
| Compatibility Object | 256-270 |
| Targets Object | 271-295 |
| Hooks (component type) | 515-567 |
| Lockfile Format | 925-1023 |
| Registry Protocol | 1054-1135 |
| Cross-Tool Portability | 1179-1211 |
| Versioning | 1213-1237 |
| Appendix D: Future Targets | 1271-1298 |

### Design Document Structure

10 existing Key Design Decisions, 6 Resolved Design Questions. New decisions start at 11.

---

## Task 1: Define Canonical Hook Event Vocabulary

**Issue:** #1 (Host-specific component adapters)

**Files:**
- Modify: `spec/specification.md` (Hooks section, lines ~515-567)

**Step 1: Add canonical event vocabulary table**

After the existing "Event Types" table (line 537), add a new subsection "Canonical Event Vocabulary":

The specification currently lists event types using Claude Code's naming convention (`PreToolUse`, `PostToolUse`, etc.). Add a canonical (tool-neutral) vocabulary that package authors use in their manifests, alongside a mapping to known host conventions.

**Research-grounded canonical event vocabulary** (derived from analysis of all five major hosts):

| Canonical Event | Claude Code | Gemini CLI | OpenCode | Codex CLI | Copilot | Description |
|---|---|---|---|---|---|---|
| `pre-tool-use` | `PreToolUse` | `BeforeTool` | `tool.execute.before` |. | `preToolUse` | Before a tool invocation |
| `post-tool-use` | `PostToolUse` | `AfterTool` | `tool.execute.after` | `AfterToolUse` | `postToolUse` | After a tool invocation completes |
| `session-start` | `SessionStart` | `SessionStart` | `session.created` |. | `sessionStart` | When a coding session begins |
| `session-end` | `SessionEnd` | `SessionEnd` | `session.deleted` |. | `sessionEnd` | When a coding session ends |
| `notification` | `Notification` | `Notification` |. | `notify` |. | On system alerts or notifications |
| `error` |. |. |. |. | `errorOccurred` | On error during agent execution |
| `pre-compact` | `PreCompact` | `PreCompress` | `experimental.session.compacting` |. |. | Before context/history compression |
| `user-prompt-submit` | `UserPromptSubmit` |. |. |. | `userPromptSubmitted` | When user submits a prompt |

**Host-specific events NOT in canonical vocabulary** (these remain host-specific and are not mapped):
- **Claude Code**: `PostToolUseFailure`, `PermissionRequest`, `Stop`, `SubagentStart`, `SubagentStop`, `TeammateIdle`, `TaskCompleted`
- **Gemini CLI**: `BeforeAgent`, `AfterAgent`, `BeforeModel`, `AfterModel`, `BeforeToolSelection`
- **OpenCode**: `stop`, `event`, `experimental.chat.system.transform`, `experimental.chat.messages.transform`, `config`, `auth`, `chat.message`, `chat.params`, `permission.ask`
- **Codex CLI**: (no additional events beyond the two listed)
- **Copilot**: (no additional events beyond the six listed)

A `. ` in the table means the host has no equivalent event. The canonical vocabulary covers the portable subset of events that exist on 3+ hosts. Hosts define many additional events beyond this vocabulary.

State that:
- Package authors MAY use either canonical names or host-specific names in `hooks.json`
- When canonical names are used, the installer MUST translate them to the active host's convention using the `targets.*.hook_events` mapping (see Task 2)
- When host-specific names are used directly, they work only on that host and are silently ignored by others (existing behavior)
- Hosts MAY define additional event types beyond this vocabulary; the canonical vocabulary covers the portable subset

**Step 2: Update the hooks.json example**

Add a second example showing canonical event names alongside the existing host-specific example:

```json
{
 "post-tool-use": [
 {
 "matcher": "Bash",
 "command": "scripts/lint-output.sh",
 "timeout": 5000
 }
 ],
 "session-start": [
 {
 "command": "scripts/check-env.sh"
 }
 ]
}
```

Add a note: "This example uses canonical event names. The installer translates these to the active host's conventions at install time. See [Targets Object](#targets-object) for the `hook_events` mapping."

**Step 3: Commit**

Commit: `docs(spec): define canonical hook event vocabulary`

---

## Task 2: Extend Targets Object with Hook Event Mapping

**Issue:** #1 (Host-specific component adapters)

**Files:**
- Modify: `spec/specification.md` (Targets Object section, lines ~271-295)

**Step 1: Add `hook_events` field documentation**

After the existing `instructions_file` documentation, add a new field:

`hook_events`. An OPTIONAL object that maps canonical event names to the host's native event type names. Keys are canonical event names (lowercase-hyphenated); values are the host's native event type strings.

**Step 2: Add `mcp_env_prefix` field documentation**

`mcp_env_prefix`. An OPTIONAL string specifying the environment variable prefix the host uses to inject MCP server credentials. For example, Copilot uses `COPILOT_MCP_` while Claude Code uses direct config injection.

**Step 3: Update the targets example**

Replace the existing example with a comprehensive one showing all fields and research-grounded hook event mappings for all five hosts:

```json
{
 "targets": {
 "claude": {
 "instructions_file": "CLAUDE.md",
 "hook_events": {
 "pre-tool-use": "PreToolUse",
 "post-tool-use": "PostToolUse",
 "session-start": "SessionStart",
 "session-end": "SessionEnd",
 "notification": "Notification",
 "pre-compact": "PreCompact",
 "user-prompt-submit": "UserPromptSubmit"
 }
 },
 "codex": {
 "instructions_file": "AGENTS.md",
 "hook_events": {
 "post-tool-use": "AfterToolUse",
 "notification": "notify"
 }
 },
 "copilot": {
 "instructions_file": ".github/copilot-instructions.md",
 "mcp_env_prefix": "COPILOT_MCP_",
 "hook_events": {
 "pre-tool-use": "preToolUse",
 "post-tool-use": "postToolUse",
 "session-start": "sessionStart",
 "session-end": "sessionEnd",
 "user-prompt-submit": "userPromptSubmitted",
 "error": "errorOccurred"
 }
 },
 "gemini": {
 "instructions_file": "GEMINI.md",
 "hook_events": {
 "pre-tool-use": "BeforeTool",
 "post-tool-use": "AfterTool",
 "session-start": "SessionStart",
 "session-end": "SessionEnd",
 "notification": "Notification",
 "pre-compact": "PreCompress"
 }
 },
 "opencode": {
 "instructions_file": "AGENTS.md",
 "hook_events": {
 "pre-tool-use": "tool.execute.before",
 "post-tool-use": "tool.execute.after",
 "pre-compact": "experimental.session.compacting"
 }
 }
 }
}
```

Note: Codex CLI has minimal hook support (only `AfterToolUse` and `notify`). OpenCode uses TypeScript plugin hooks rather than shell-based hooks, so only the closest equivalents are mapped. Missing canonical events in a host's `hook_events` mean the host has no equivalent. hooks using those canonical names are silently skipped on that host.

**Step 4: Update the explanation paragraph**

The current text says "The contents of `targets` are not strictly defined by this specification." Update to: "The `targets` object supports the following standard fields. Tool-specific adapters MAY define additional fields beyond these."

Add a table of standard target fields:

| Field | Type | Description |
|---|---|---|
| `instructions_file` | `string` | Override path for the instructions file on this host |
| `hook_events` | `object` | Map of canonical event names to host-native event names |
| `mcp_env_prefix` | `string` | Environment variable prefix for MCP server credential injection |

**Step 5: Commit**

Commit: `docs(spec): extend targets object with hook event and MCP env mapping`

---

## Task 3: Add Per-Component Host Scoping

**Issue:** #1 (Host-specific component adapters)

**Files:**
- Modify: `spec/specification.md` (Components Object section, lines ~215-228)

**Step 1: Introduce structured component declarations**

Currently, `components.skills` is `string[]` (just paths). To support per-component metadata like host scoping, allow an alternative structured form. Add after the Components Object table:

"Each component field supports two declaration forms:

1. **Simple form** (string): A path to the component. The component is available on all hosts.
2. **Structured form** (object): An object with `path` and optional metadata fields. Use this to scope components to specific hosts."

Add the structured form fields table:

| Field | Required | Type | Description |
|---|---|---|---|
| `path` | REQUIRED | `string` | Path to the component (same as the simple form string value) |
| `hosts` | OPTIONAL | `string[]` | List of host identifiers on which this component should be installed. If omitted, the component is installed on all hosts. |

**Step 2: Add example**

```json
{
 "components": {
 "skills": [
 "skills/universal-skill",
 {
 "path": "skills/claude-specific-skill",
 "hosts": ["claude"]
 }
 ],
 "hooks": "hooks/hooks.json",
 "agents": [
 "agents/universal-agent",
 {
 "path": "agents/copilot-agent",
 "hosts": ["copilot"]
 }
 ]
 }
}
```

Add a note: "When an installer encounters a component scoped to hosts that do not include the active host, it MUST skip that component silently. The installer MUST NOT treat this as an error."

**Step 3: Commit**

Commit: `docs(spec): add per-component host scoping to components object`

---

## Task 4: Add Update Discovery to Registry Protocol

**Issue:** #2 (Async update discovery and security advisory checks)

**Files:**
- Modify: `spec/specification.md` (Registry Protocol section, lines ~1054-1135)

**Step 1: Add "Version Discovery" subsection**

After the existing "Resolution Behavior" subsection (line ~1133), add a new subsection:

"### Version Discovery

Registries SHOULD provide a version endpoint that enables efficient update checking without downloading the full index.

**Version endpoint format:**

A registry MAY expose per-package version information at a predictable URL derived from the registry base URL:

```
{registry-base-url}/packages/{name}/versions.json
```

**Response schema:**

```json
{
 "name": "api-testing",
 "latest": "2.1.0",
 "versions": [
 {
 "version": "2.1.0",
 "published_at": "2026-03-01T12:00:00Z",
 "checksum": "sha256:...",
 "url": "https://..."
 },
 {
 "version": "2.0.0",
 "published_at": "2026-02-15T12:00:00Z",
 "checksum": "sha256:...",
 "url": "https://..."
 }
 ]
}
```

| Field | Required | Type | Description |
|---|---|---|---|
| `name` | REQUIRED | `string` | Package name |
| `latest` | REQUIRED | `string` | Latest stable version (semver) |
| `versions` | REQUIRED | `array` | All published versions, newest first |

Each version entry uses the same fields as a registry package entry.

Registries SHOULD support `ETag` and `If-None-Match` headers to enable efficient polling. An installer that checks for updates SHOULD cache responses and use conditional requests to minimize bandwidth."

**Step 2: Add "Security Advisories" subsection**

"### Security Advisories

Registries MAY publish security advisories for packages. An advisory indicates that one or more versions of a package have a known vulnerability.

**Advisory endpoint format:**

```
{registry-base-url}/advisories.json
```

**Response schema:**

```json
{
 "advisories": [
 {
 "id": "CCPKG-2026-001",
 "package": "vulnerable-pkg",
 "affected_versions": "<1.2.3",
 "severity": "high",
 "title": "Command injection in hook script",
 "description": "...",
 "fixed_in": "1.2.3",
 "published_at": "2026-03-01T00:00:00Z",
 "url": "https://..."
 }
 ]
}
```

| Field | Required | Type | Description |
|---|---|---|---|
| `id` | REQUIRED | `string` | Unique advisory identifier |
| `package` | REQUIRED | `string` | Affected package name |
| `affected_versions` | REQUIRED | `string` | Semver range of affected versions |
| `severity` | REQUIRED | `string` | One of: `critical`, `high`, `medium`, `low` |
| `title` | REQUIRED | `string` | Short description of the vulnerability |
| `description` | OPTIONAL | `string` | Detailed description |
| `fixed_in` | OPTIONAL | `string` | Version that fixes the vulnerability |
| `published_at` | REQUIRED | `string` | ISO 8601 timestamp |
| `url` | OPTIONAL | `string` | Link to full advisory details |

Installers that support update discovery SHOULD check the advisory endpoint and SHOULD surface advisories affecting installed packages. The urgency of notification is an implementation concern."

**Step 3: Commit**

Commit: `docs(spec): add version discovery and security advisory endpoints to registry protocol`

---

## Task 5: Add Remote Component References Section

**Issue:** #3 (Remote skill references)

**Files:**
- Modify: `spec/specification.md` (new section after Lazy Loading, before Registry Protocol)

**Step 1: Add "Remote Component References" section**

Add a new top-level section:

"## Remote Component References

Components declared in a manifest MAY reference remote sources instead of local archive paths. This enables lightweight distribution of individual components without requiring a full `.ccpkg` archive.

### Remote Component Declaration

A component path that begins with `https://` is a remote reference. The installer MUST fetch the component from the URL and cache it locally before registration.

In the structured component form (see [Components Object](#components-object)), a remote component uses the `url` field instead of `path`:

```json
{
 "components": {
 "skills": [
 "skills/local-skill",
 {
 "url": "https://example.com/skills/remote-skill/SKILL.md",
 "checksum": "sha256:a1b2c3d4...",
 "cache_ttl": 86400
 }
 ]
 }
}
```

### Remote Component Fields

| Field | Required | Type | Description |
|---|---|---|---|
| `url` | REQUIRED | `string` | HTTPS URL to the component file or directory |
| `checksum` | REQUIRED | `string` | SHA-256 checksum of the remote content. Format: `sha256:<hex>` |
| `cache_ttl` | OPTIONAL | `number` | Cache duration in seconds. Default: 86400 (24 hours). `0` means always fetch. |
| `hosts` | OPTIONAL | `string[]` | Host scoping (same semantics as local components) |

### Security Requirements

- Remote component URLs MUST use HTTPS.
- The `checksum` field is REQUIRED for all remote references. Installers MUST verify the checksum after fetching and MUST reject content that does not match.
- Authors who publish remote skills at mutable URLs MUST update the checksum in their manifest when the remote content changes.

### Caching

Installers MUST cache fetched remote components locally. When the cache is valid (within `cache_ttl`), the installer MUST use the cached copy without network access. When the cache is expired, the installer SHOULD attempt to refresh and MUST fall back to the cached copy if the network is unavailable.

### Lockfile Integration

Remote components are recorded in the lockfile with their resolved URL, checksum, and fetch timestamp. See [Lockfile Format](#lockfile-format) for the `remote_sources` field.

### Direct URL Installation

A conforming installer MAY support installing a single component directly from a URL without a manifest. This is a convenience shortcut for single-component distribution. The behavior and syntax of direct URL installation is an implementation concern and is not specified here."

**Step 2: Commit**

Commit: `docs(spec): add remote component references section`

---

## Task 6: Expand Lockfile for Update Tracking and Remote Sources

**Issue:** #2 + #3

**Files:**
- Modify: `spec/specification.md` (Lockfile Format section, lines ~925-1023)

**Step 1: Add update tracking fields to install record**

Add new fields to the install record table (after the existing `components` field):

| Field | Type | Description |
|---|---|---|
| `remote_sources` | `object` | Map of component path to remote source metadata. Only present for packages with remote component references. Keys are component identifiers; values are objects with `url`, `checksum`, `fetched_at`, and `cache_ttl`. |

**Step 2: Add remote_sources schema**

Add after the install record table:

"**Remote source entry fields:**

| Field | Type | Description |
|---|---|---|
| `url` | `string` | The URL from which the component was fetched |
| `checksum` | `string` | SHA-256 checksum of the fetched content |
| `fetched_at` | `string` | ISO 8601 timestamp of last successful fetch |
| `cache_ttl` | `number` | Cache duration in seconds from the manifest declaration |

**Step 3: Update the lockfile example**

Add a `remote_sources` field to the `api-testing` example entry:

```json
"remote_sources": {
 "skills/cloud-helper": {
 "url": "https://example.com/skills/cloud-helper/SKILL.md",
 "checksum": "sha256:b2c3d4e5...",
 "fetched_at": "2026-02-14T12:00:00Z",
 "cache_ttl": 86400
 }
}
```

**Step 4: Commit**

Commit: `docs(spec): add remote source and update tracking fields to lockfile`

---

## Task 7: Add Component Portability Matrix

**Issue:** #4 (Copilot cross-platform) + #1 (Host-specific adapters)

**Files:**
- Modify: `spec/specification.md` (Cross-Tool Portability section, lines ~1179-1211)

**Step 1: Add Component Portability Matrix**

After the existing "Universal Components" table, add a "Component Portability Matrix" subsection:

"### Component Portability Matrix

The following matrix indicates the portability status of each component type across known hosts. This is informational. hosts not listed here may support any subset of components.

| Component | Claude Code | Copilot | Codex CLI | Gemini CLI | OpenCode |
|---|---|---|---|---|---|
| Skills (SKILL.md) | Native | Via instructions | Native | Native | Native |
| MCP servers | Native | Native (COPILOT_MCP_ prefix) | Native | Native | Native |
| LSP servers | Native (via plugins) | Not supported | Not supported | Experimental (TS/JS) | Experimental (27+ languages) |
| Hooks | Native (14 events) | Native (6 events) | Minimal (2 events) | Native (11 events) | Plugin hooks (TypeScript) |
| Agents (AGENT.md) | Native | Native (.github/agents/) | Not supported | Experimental (sub-agents) | Native (custom agents) |
| Commands | Native | Not supported | Deprecated (prompts) | Native (TOML files) | Native (Markdown files) |
| Instructions | CLAUDE.md |.github/copilot-instructions.md | AGENTS.md | GEMINI.md (configurable) | AGENTS.md (fallback: CLAUDE.md) |

**Key:**
- **Native**: Component type is natively supported by the host
- **Via [mechanism]**: Component concept maps to a different host mechanism (adapter needed)
- **Not supported**: Host has no equivalent; component is silently skipped
- **Partial**: Some features of the component type work; others do not

Package authors SHOULD use per-component host scoping (see [Components Object](#components-object)) to include host-specific variants of components. Authors SHOULD NOT assume all hosts support all component types."

**Step 2: Update Tool-Specific Adapters list**

Add a fourth adapter mechanism to the existing list:

"4. **Per-component host scoping.** The `hosts` field in structured component declarations limits a component to specific hosts. Installers silently skip components not targeted at the active host."

**Step 3: Update Portability Guidelines**

Add new guidelines grounded in research findings:
- "Use per-component `hosts` scoping to include host-specific hooks or agents alongside universal skills."
- "When targeting Copilot, note that MCP server credentials are injected via `COPILOT_MCP_` environment variables. Use `targets.copilot.mcp_env_prefix` to declare this."
- "Hooks are the most portable after Skills and MCP. four of five hosts (Claude Code, Copilot, Gemini CLI, OpenCode) have native hook systems. Codex CLI has minimal support (two events only). Use canonical event names for maximum portability."
- "Agents are not yet portable across hosts. Each host uses a different agent definition format and execution model. Scope agents to specific hosts via the `hosts` field."
- "LSP servers are only natively supported by Claude Code. Gemini CLI and OpenCode have experimental support. Scope LSP components to supported hosts."

**Step 4: Commit**

Commit: `docs(spec): add component portability matrix and scoping guidance`

---

## Task 8: Update Manifest Schema

**Files:**
- Modify: `spec/schemas/manifest.schema.json`

**Step 1: Update components schema for structured form**

Currently `components.skills` and `components.agents` are `{"type": "array", "items": {"type": "string"}}`. Change them to accept both simple and structured forms:

```json
"skills": {
 "type": "array",
 "items": {
 "oneOf": [
 {"type": "string"},
 {
 "type": "object",
 "required": ["path"],
 "additionalProperties": false,
 "properties": {
 "path": {"type": "string", "description": "Path to the skill directory."},
 "hosts": {
 "type": "array",
 "items": {"type": "string"},
 "description": "Host identifiers on which this component should be installed. Omit for all hosts."
 },
 "url": {
 "type": "string",
 "format": "uri",
 "description": "HTTPS URL for a remote component reference. Mutually exclusive with path."
 },
 "checksum": {
 "type": "string",
 "pattern": "^sha256:[a-f0-9]{64}$",
 "description": "SHA-256 checksum for remote content verification. Required when url is present."
 },
 "cache_ttl": {
 "type": "number",
 "minimum": 0,
 "description": "Cache duration in seconds for remote content. Default: 86400."
 }
 }
 }
 ]
 }
}
```

Apply the same `oneOf` pattern to `agents` and `commands`.

**Step 2: Update targets schema**

Replace the `additionalProperties: true` with specific standard fields:

```json
"targets": {
 "type": "object",
 "description": "Per-target overrides. Keys are host identifiers.",
 "additionalProperties": {
 "type": "object",
 "properties": {
 "instructions_file": {
 "type": "string",
 "description": "Override path for the instructions file on this host."
 },
 "hook_events": {
 "type": "object",
 "description": "Map of canonical event names to host-native event names.",
 "additionalProperties": {"type": "string"}
 },
 "mcp_env_prefix": {
 "type": "string",
 "description": "Environment variable prefix for MCP server credential injection."
 }
 },
 "additionalProperties": true
 }
}
```

**Step 3: Commit**

Commit: `docs(schema): update manifest schema for host scoping, remote refs, and target fields`

---

## Task 9: Add Design Decisions 11-14

**Files:**
- Modify: `docs/plans/2026-02-14-ccpkg-design.md`

**Step 1: Add Key Design Decision 11. Canonical Hook Event Vocabulary**

After existing decision 10, add:

Decision: Define a canonical (tool-neutral) hook event vocabulary that maps to host-specific event names via the `targets.*.hook_events` manifest field.

Rationale: Research across all five major hosts confirms that each names the same events differently. Claude Code uses `PreToolUse`, Gemini CLI uses `BeforeTool`, Copilot uses `preToolUse`, OpenCode uses `tool.execute.before`, and Codex CLI uses `AfterToolUse` (for post-tool only). The canonical vocabulary covers the eight events that exist on 3+ hosts. The mapping lives in the manifest's `targets` object, so no runtime translation layer is needed. the installer rewrites hook event names at install time. Host-specific events beyond the vocabulary (e.g., Gemini's `BeforeModel`/`AfterModel`, Claude Code's `SubagentStart`/`SubagentStop`) remain usable via host-specific names.

Alternatives considered:
- **Include all host variants in hooks.json**. works (hosts ignore unknown events) but leads to duplicated hook definitions for each host
- **Runtime translation by host**. requires host changes; each host would need to understand canonical names
- **Convention only (no formal vocabulary)**. leaves authors guessing which names to use

**Step 2: Add Key Design Decision 12. Update Discovery Protocol**

Decision: The registry protocol defines version discovery and security advisory endpoints. Update checking behavior (when to check, how to notify) is an implementation concern, not specified.

Rationale: The spec defines the data format (what a version endpoint returns, what an advisory looks like). How an installer uses that data. background checks, caching strategy, notification UX. varies by implementation and is deliberately left unspecified. This separation lets the spec stay stable while implementations innovate on UX.

Alternatives considered:
- **Spec-mandated update checking**. too prescriptive; some installers may run in CI where background checks are inappropriate
- **No registry support for updates**. forces implementations to download and parse the full index for every update check
- **Push-based updates (webhooks)**. requires persistent infrastructure; pull-based is simpler and sufficient

**Step 3: Add Key Design Decision 13. Remote Component References**

Decision: Components may reference remote HTTPS URLs instead of local paths. Remote references require checksums and support local caching with TTL-based expiry.

Rationale: Not every skill needs the overhead of a full `.ccpkg` archive. A single SKILL.md hosted on GitHub or a CDN can be referenced directly. Checksums are mandatory because mutable URLs are a security risk. the installer must verify content hasn't changed unexpectedly. Caching with offline fallback ensures remote skills work without network after the initial fetch.

Alternatives considered:
- **Archive-only distribution**. simpler but forces overhead for single-file skills
- **Remote references without checksums**. too risky; mutable URLs could serve malicious content
- **Content-addressed storage only**. more secure but requires infrastructure most authors don't have

**Step 4: Add Key Design Decision 14. Cross-Platform Host Strategy**

Decision: The spec defines a component portability matrix and standardized `targets` fields (`hook_events`, `mcp_env_prefix`) to enable cross-platform packages. Per-component `hosts` scoping lets authors include host-specific variants. How packages are installed on each host (e.g., Copilot's `copilot-setup-steps.yml`) is an implementation concern.

Rationale: Research confirms each host has fundamentally different installation and extension mechanisms. Claude Code uses `extraKnownMarketplaces` and plugin directories; Copilot uses `copilot-setup-steps.yml` GitHub Actions workflows and `.github/agents/`; Gemini CLI uses `.gemini/extensions/` with `gemini-extension.json` manifests; OpenCode uses `.opencode/plugins/` with TypeScript modules; Codex CLI uses `.codex/` with TOML config. The spec's job is to define the manifest format. what a package author declares. not how each host consumes it. These are implementation details of each installer, not format concerns.

Alternatives considered:
- **Host-specific manifest sections**. couples the spec to specific hosts; breaks when new hosts emerge
- **Separate manifests per host**. violates the "one package, many hosts" principle
- **Spec-defined install commands per host**. conflates specification with implementation

**Step 5: Update Resolved Design Questions**

Add question 7:

"7. **Host-specific event names**. Resolved: Define a canonical vocabulary (`pre-tool-use`, `post-tool-use`, etc.) and map to host-native names via `targets.*.hook_events`. Installers rewrite event names at install time. Packages may also use host-native names directly for single-host packages."

**Step 6: Commit**

Commit: `docs(design): add design decisions 11-14 for host adapters, updates, remote refs, cross-platform`

---

## Task 10: Capture Decisions to Mnemonic Memory

**Step 1: Capture key decisions**

Capture the following to mnemonic:

- `_semantic/decisions`: "Canonical hook event vocabulary maps to host-native names via targets.hook_events"
- `_semantic/decisions`: "Update discovery protocol is spec-level format, not implementation-mandated behavior"
- `_semantic/decisions`: "Remote component references require HTTPS + mandatory checksums + cache TTL"
- `_semantic/decisions`: "Cross-platform strategy separates manifest format from per-host install mechanics"
- `_procedural/patterns`: "Structured component declarations support both string paths and objects with hosts/url/checksum"

---

## Execution Notes

### Team Structure

| Agent | Role | Tasks |
|---|---|---|
| **spec-editor** | Revise specification.md | Tasks 1, 2, 3, 4, 5, 6, 7 (sequential) |
| **schema-editor** | Update manifest schema | Task 8 |
| **design-editor** | Revise design document | Task 9 |
| **memory-curator** | Capture to mnemonic | Task 10 |

Tasks 1-7 are sequential (all modify `spec/specification.md`). Tasks 8, 9, 10 are independent of each other and can run in parallel. All four agents can start in parallel since they modify different files.

### Commit Strategy

| Task | Commit Message |
|---|---|
| 1 | `docs(spec): define canonical hook event vocabulary` |
| 2 | `docs(spec): extend targets object with hook event and MCP env mapping` |
| 3 | `docs(spec): add per-component host scoping to components object` |
| 4 | `docs(spec): add version discovery and security advisory endpoints to registry protocol` |
| 5 | `docs(spec): add remote component references section` |
| 6 | `docs(spec): add remote source and update tracking fields to lockfile` |
| 7 | `docs(spec): add component portability matrix and scoping guidance` |
| 8 | `docs(schema): update manifest schema for host scoping, remote refs, and target fields` |
| 9 | `docs(design): add design decisions 11-14 for host adapters, updates, remote refs, cross-platform` |

### What This Plan Does NOT Cover

- **CLI command design** (`ccpkg outdated`, `ccpkg audit`, `ccpkg update`, `ccpkg copilot setup`). implementation plan
- **Installer algorithms** (how to perform background checks, caching strategies, notification UX). implementation plan
- **Test suites**. no tests exist for the spec itself
- **Agent invocation adapters**. deferred; the research shows agents work differently across hosts (Claude Code: AGENT.md with subagent spawning; Copilot:.github/agents/ with YAML frontmatter; Gemini CLI: experimental sub-agents with A2A protocol; OpenCode: JSON or Markdown agent definitions). A cross-platform agent adapter is more complex than hook event mapping and warrants a separate design effort
